<!DOCTYPE HTML>
<!--
	Paradigm Shift by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>CS 180 Project 2: </title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<meta name="description" content="" />
		<meta name="keywords" content="" />
		<link rel="stylesheet" href="assets/css/main.css" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<style>
			body {
            font-family: 'Arial', sans-serif; /* Choose a clean, modern font */
            font-size: 16px; /* Default font size */
            line-height: 1.6; /* Improve line spacing for readability */
            color: #333; /* Use a dark gray color instead of pure black */
            margin: 20px; /* Add some space around the page */
			justify-content: center;
            align-items: center;
        	}

			h1, h2, h3, h4, h5, h6 {
				font-family: 'Georgia', serif; /* Use a serif font for headings */
				color: #222; /* Slightly darker color for headings */
			}

			p {
				margin-bottom: 15px; /* Add spacing between paragraphs */
			}

			a {
				color: #007BFF; /* Use a consistent color for links */
				text-decoration: none; /* Remove underline from links */
			}

			a:hover {
				text-decoration: underline; /* Add underline on hover for links */
			}

			.caption {
				font-size: 14px; /* Slightly smaller font for captions */
				color: #555; /* A lighter gray color for captions */
			}
			.image-container {
				display: flex;
				justify-content: center;
            	align-items: center;
				gap: 20px;
				margin: 20px 0;
			}
			.image-box {
				text-align: center;
			}
			img {
				max-width: 80%;
				height: auto;
				justify-content: center;
            	align-items: center;
			}
			.caption {
				white-space: pre-line;
				font-family: Arial, sans-serif;
				font-size: 14px;
			}

			.center {
			display: block;
			margin-left: auto;
			margin-right: auto;
			width: 50%;
			}
		</style>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Intro -->
					<section class="intro">
						<header>
							
							<h1>CS 180 Project 2</h1>
							<h3>Table of Contents</h3>
							<ul class="actions">
								<li><a href="#intro" class="arrow scrolly"><span class="label">Introduction</span></a></li>
								<li><a href="#finite" class="arrow scrolly"><span class="label">Finite Difference Operator</span></a></li>
								<li><a href="#dog" class="arrow scrolly"><span class="label">Derivative of Gaussian Filter</span></a></li>
								<li><a href="#sharpening" class="arrow scrolly"><span class="label">Image Sharpening</span></a></li>
								<li><a href="#hybrid" class="arrow scrolly"><span class="label">Hybrid Images</span></a></li>
								<li><a href="#stacks" class="arrow scrolly"><span class="label">Gaussian and Laplace Stacks</span></a></li>
								<li><a href="#blending" class="arrow scrolly"><span class="label">Multiresolution Blending</span></a></li>
							</ul>

							<!-- Section -->
				<section id="intro">
					<header>
						<h2>Introduction</h2>
					</header>

							<p>This project covers several frequency-based techniques for image manipulation and processing. These methods include:</p>
<ul>
    <li>Enhancing image sharpness by amplifying high-frequency components</li>
    <li>Detecting edges through the use of finite difference kernels</li>
    <li>Generating hybrid images by combining high-frequency elements from one image with low-frequency elements from another</li>
    <li>Blending multiple images across various frequency levels using Gaussian and Laplacian stacks</li>
</ul>
<p>These approaches showcase the diverse applications of frequency analysis in creating innovative and interesting image processing effects.</p>
					</section>

				<!-- Section -->
					<section id="finite">
						<header>
							<h2>Finite Difference Operator</h2>
								<h3>Method</h3>
						</header>
						<div class="content">
							<p>
								<p>Two finite difference kernels were implemented as NumPy arrays to compute partial derivatives:</p>
								<ul>
									<li><code>dx_kernel = np.array([[1, -1]])</code> for horizontal changes</li>
									<li><code>dy_kernel = np.array([[1], [-1]])</code> for vertical changes</li>
								</ul>
								<p>These kernels were applied to the original image using <code>scipy.signal.convolve2d</code> with the parameter <code>mode='same'</code>, resulting in two images representing partial derivatives in the x and y directions.</p>
								<p>To create a single edge image, the gradient magnitude was calculated at each pixel using:</p>
								<pre><code>np.sqrt(dx_deriv ** 2 + dy_deriv ** 2)</code></pre>
								<p>This operation effectively computes the L2 norm of the gradient vector formed by corresponding pixel values from the two partial-derivative images, producing the final edge-detected image.</p>
							
								<header>
									<h3>Outputs</h3>
								</header>
							

							<div class="image-container">
								<div class="image-box">
									<img src="media\cameraman_dx.jpg" alt="cameraman_dx" />
									<p class="caption">Cameraman (dx)</p>
								</div>
								<div class="image-box">
									<img src="media\cameraman_dy.jpg" alt="cameraman_dy" />
									<p class="caption">Cameraman (dy)</p>
								</div>
							</div>

							<div class="image-container"></div>

								<div class="image-box"></div>
									<img src="media\cameraman_grad_bin.jpg" alt="cameraman_grad_bin" class="center"/>
									<p class="caption"style="text-align: center;">Cameraman (Gradient, binarized)</p>
								</div>

							</div>

							</div>
					</section>

				<!-- Section -->
				<section id="dog">
					<header>
						<h2>Derivative of Gaussian Filter</h2>
							<h3>Method</h3>
					</header>
					<div class="content">
						<p>
							<p>I took a different approach to edge detection by pre-processing the Gaussian kernels:</p>
<ol>
  <li>First, I convolved the Gaussian kernels with the <code>dx</code> and <code>dy</code> finite difference kernels. This produced two new kernels: <code>gaussian_dx</code> and <code>gaussian_dy</code>.</li>
  <li>These new kernels effectively represent the partial derivatives of the Gaussian kernel with respect to x and y.</li>
  <li>Next, I applied these modified kernels to the original image through convolution. This step generated two partial derivative images.</li>
  <li>Finally, I combined these partial derivative images into a single edge image. For this, I used the same method as before, calculating the magnitude of the gradient at each pixel.</li>
</ol>
<p>This technique allowed me to integrate the Gaussian smoothing and differentiation steps, potentially offering a more efficient edge detection process. I also chose to experiment with different values for the kernel size and sigma and visualized the differences below:</p>
							<header>
								<h3>Outputs</h3>
							</header>
						

						<div class="image-container">
							<div class="image-box">
								<img src="media\cameraman_dx_gaussian.jpg" alt="cameraman_dx" />
								<p class="caption">Cameraman (dx_gaussian)</p>
							</div>
							<div class="image-box">
								<img src="media\cameraman_dy_gaussian.jpg" alt="cameraman_dy" />
								<p class="caption">Cameraman (dy_gaussian)</p>
							</div>

						</div>

						<div class="image-container">
							<div class="image-box">
								<img src="media\cameraman_dog_6_1.jpg" alt="cameraman_grad_bin"/>
								<p class="caption">Cameraman (ksize = 6, sigma = 1)</p>
							</div>
							<div class="image-box">
								<img src="media\cameraman_dog_12_2.jpg" alt="cameraman_grad_bin"/>
								<p class="caption">Cameraman (ksize = 12, sigma = 2)</p>
							</div>

						</div>

						<p>
							As expected, the results of the finite difference operator and derivative of gaussian filter were quite similar in goal. The key difference was that the smoothing prevented too many additional artifacts from forming and were much better at edge detection than solely using the gradient earlier.
							For concrete differences, observe the difference in the "sky" in both pictures. Without smoothing, there are some white spots. Second, the edge corresponding to the back of the cameraman is captured in greater detail with smoothing.
						</p>

				</section>

				<!-- Section -->
				<section id="sharpening">
					<header>
						<h2>Image Sharpening</h2>
							<h3>Method</h3>
					</header>
					<div class="content">
						<p>
							<p>Here's how I sharpened an image:</p>

<ol>
  <li>Blur the original image by convolving it with a Gaussian kernel.</li>
  <li>Extract high-frequency components: <code>edges = img - img_blur</code></li>
  <li>Enhance the image: <code>sharpened = img + α * edges</code></li>
</ol>

<p>Where α is a constant that controls the sharpening intensity. I experiment with the value of alpha until it looked aesthetically pleasing. 
For the first set of pictures, I set ksize=10 and sigma=2 when blurring and used alpha=1. This was done step-by-step.
For the second set of pictures, I used the unsharp mask filter I created. I first blurred the image with sigma=2 and then sharpened it with alpha=3 to emphasize the effect. </p>
					
							<header>
								<h3>Outputs</h3>
							</header>
						

						<div class="image-container">
							<div class="image-box">
								<img src="media\taj_sharpen.jpg" alt="taj_sharpen" />
								<p class="caption">Sharpening Taj step-by-step</p>
							</div>
						</div>

						<div class="image-container"></div>
							<div class="image-box">
								<img src="media\taj_resharpen.jpg" alt="taj_resharpen" />
								<p class="caption">Sharpening blurred taj with unsharp mask filter</p>
							</div>
						</div>

						<p>
							When working with the original image, the effects of sharpening were prominent. As the details outline indicates, we are adding emphasis to the various bricks of the taj mahal as well as the lined bushes near it.
							If we blur the original image, we have certainly lost some information, and so we cannot expect to reconstruct details we didn't have access to. Remarkably still, the filter does a good job at highlighting the prominent edges.
						</p>

						<header>
							<h3>Custom Images</h3>
						</header>

				</section>


				<!-- Section -->
				<section id="finite">
					<header>
						<h2>Derivative of Gaussian Filter</h2>
							<h3>Method</h3>
					</header>
					<div class="content">
						<p>
							<p>I took a different approach to edge detection by pre-processing the Gaussian kernels:</p>
<ol>
  <li>First, I convolved the Gaussian kernels with the <code>dx</code> and <code>dy</code> finite difference kernels. This produced two new kernels: <code>gaussian_dx</code> and <code>gaussian_dy</code>.</li>
  <li>These new kernels effectively represent the partial derivatives of the Gaussian kernel with respect to x and y.</li>
  <li>Next, I applied these modified kernels to the original image through convolution. This step generated two partial derivative images.</li>
  <li>Finally, I combined these partial derivative images into a single edge image. For this, I used the same method as before, calculating the magnitude of the gradient at each pixel.</li>
</ol>
<p>This technique allowed me to integrate the Gaussian smoothing and differentiation steps, potentially offering a more efficient edge detection process. I also chose to experiment with different values for the kernel size and sigma and visualized the differences below:</p>
							<header>
								<h3>Outputs</h3>
							</header>
						

						<div class="image-container">
							<div class="image-box">
								<img src="media\cameraman_dx_gaussian.jpg" alt="cameraman_dx" />
								<p class="caption">Cameraman (dx_gaussian)</p>
							</div>
							<div class="image-box">
								<img src="media\cameraman_dy_gaussian.jpg" alt="cameraman_dy" />
								<p class="caption">Cameraman (dy_gaussian)</p>
							</div>

						</div>

						<div class="image-container">
							<div class="image-box">
								<img src="media\cameraman_dog_6_1.jpg" alt="cameraman_grad_bin"/>
								<p class="caption">Cameraman (ksize = 6, sigma = 1)</p>
							</div>
							<div class="image-box">
								<img src="media\cameraman_dog_12_2.jpg" alt="cameraman_grad_bin"/>
								<p class="caption">Cameraman (ksize = 12, sigma = 2)</p>
							</div>

						</div>

						<p>
							As expected, the results of the finite difference operator and derivative of gaussian filter were quite similar in goal. The key difference was that the smoothing prevented too many additional artifacts from forming and were much better at edge detection than solely using the gradient earlier.
							For concrete differences, observe the difference in the "sky" in both pictures. Without smoothing, there are some white spots. Second, the edge corresponding to the back of the cameraman is captured in greater detail with smoothing.
						</p>

				</section>




	</body>
</html>